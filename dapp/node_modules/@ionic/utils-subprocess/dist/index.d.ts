/// <reference types="node" />
import { ChildProcess, ForkOptions, SpawnOptions } from 'child_process';
export declare const ERROR_COMMAND_NOT_FOUND = "ERR_SUBPROCESS_COMMAND_NOT_FOUND";
export declare const ERROR_NON_ZERO_EXIT = "ERR_SUBPROCESS_NON_ZERO_EXIT";
export declare const ERROR_SIGNAL_EXIT = "ERR_SUBPROCESS_SIGNAL_EXIT";
export declare const TILDE_PATH_REGEX: RegExp;
export declare function expandTildePath(p: string): string;
export declare class SubprocessError extends Error {
    readonly name = "SubprocessError";
    message: string;
    stack: string;
    code?: typeof ERROR_COMMAND_NOT_FOUND | typeof ERROR_NON_ZERO_EXIT | typeof ERROR_SIGNAL_EXIT;
    error?: Error;
    output?: string;
    signal?: string;
    exitCode?: number;
    constructor(message: string);
}
export interface SubprocessOptions extends SpawnOptions {
}
export declare class Subprocess {
    name: string;
    args: ReadonlyArray<string>;
    protected readonly path?: string;
    protected _options: SpawnOptions;
    constructor(name: string, args: ReadonlyArray<string>, options?: SubprocessOptions);
    readonly options: Readonly<SpawnOptions>;
    output(): Promise<string>;
    combinedOutput(): Promise<string>;
    run(): Promise<void> & {
        p: ChildProcess;
    };
    spawn(): ChildProcess;
    bashify(): string;
}
export declare function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): ChildProcess;
export declare function fork(modulePath: string, args?: ReadonlyArray<string>, options?: ForkOptions & Pick<SpawnOptions, 'stdio'>): ChildProcess;
export interface WhichOptions {
    PATH?: string;
}
export declare function which(command: string, { PATH }?: WhichOptions): Promise<string>;
